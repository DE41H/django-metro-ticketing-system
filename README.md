# üöá Django Metro Ticketing System

A robust, full-stack web application built with **Django** designed to model and manage a modern metropolitan rail network. The system provides core functionalities for user authentication, dynamic route calculation, ticket purchasing, and interactive network visualization, all deployed efficiently using a Dockerized, multi-container architecture.

## ‚ú® Core Application Features

The system's strength lies in its ability to handle complex network data and present it in an accessible format:

| Feature Category | Description | Technical Implementation |
| :--- | :--- | :--- |
| **Network Data Modeling** | Manages Stations, Lines, and the relationships between them (Neighbors) within a relational database. | Django Models (`Station`, `Line`, etc.) with `prefetch_related` for optimized data retrieval. |
| **Efficient Route Calculation** | Calculates the shortest or most efficient path between any two active stations in the network. | **NetworkX** integration in `utils.py`, using the **Breadth-First Search (BFS)** algorithm to find paths through the graph structure defined by station neighbors. |
| **Dynamic Network Mapping** | Generates a visually interactive, force-directed graph of the entire operational rail network. | **Pyvis** (a wrapper for Vis.js) used by `create_map` in `utils.py` to convert the NetworkX graph into an embedded, navigable HTML visualization. |
| **Configuration Caching** | Prevents map regeneration on every request. The map file is hashed based on the current state of the database (Stations, Lines, Neighbors). | Uses Django's Caching framework (`django.core.cache`) and `sha512` hashing in `get_hash()` to ensure the map is only rebuilt when the network configuration changes. |
| **User Authentication** | Provides secure, comprehensive workflows for user registration, login, and profile management. | **`django-allauth`** integrated for a professional and secure authentication experience. |
| **Ticketing System** | Includes the necessary views and logic for users to search available routes, purchase tickets, and view their journey history. | Custom Django application logic (inferred from template references like `tickets:ticket_purchase`). |

---

## ‚öôÔ∏è Technology Stack & Architecture

This project adopts a modern, containerized architecture suitable for production scale.

### Core Dependencies

| Component | Technology / Language | Primary Role |
| :--- | :--- | :--- |
| **Application Logic** | Python / Django | Core web framework, ORM, and business logic execution. |
| **Database** | PostgreSQL (`postgres:14-alpine`) | The robust and ACID-compliant relational database for persistent data storage. |
| **Graphing Engine** | NetworkX & Pyvis | Mathematical graph theory for routing and dynamic visualization. |
| **Authentication** | `django-allauth` | Handles all user session and security processes. |

### Production Multi-Container Architecture

The system is deployed using a standard three-tier service architecture defined in `compose.prod.yaml`:

| Service Name | Docker Image | Role in System | Port |
| :--- | :--- | :--- | :--- |
| **`db`** | `postgres:14-alpine` | Database server. Includes a `healthcheck` to ensure the service is ready before the `web` container starts. | Exposed internally on `5432`. |
| **`web`** | Custom (built from `Dockerfile.prod`) | Application server running **Gunicorn** to serve the Django application. | Exposed internally on `8080`. |
| **`nginx`** | `nginx:alpine` | **Reverse Proxy** and **Static/Media File Server**. Handles all external traffic, routing API calls to `web:8080`, and serving assets directly from volumes. | Exposed externally on `80` and `8080`. |

#### Data Persistence and Volume Strategy
All critical data is stored outside the application containers using named Docker Volumes, which are shared between services.  This ensures data is never lost when containers are rebuilt or updated.

* `postgres_data`: Persists all database files (`/var/lib/postgresql/data`).
* `static_volume`: Stores files generated by `collectstatic` (`/app/staticfiles`), shared **read-only** with Nginx.
* `media_volume`: Stores dynamically generated files, such as the map HTML files (`/app/mediafiles`), shared **read-only** with Nginx.

---

## üöÄ Environment Setup & Deployment

### 1. Production Deployment (Docker Compose)

The production environment is configured for maximum performance and security, including a dedicated non-root user (`appuser` UID 5678) as defined in `Dockerfile.prod`.

**Prerequisites:** Docker, Docker Compose, and a working internet connection.

1.  **Clone the Repository:**
    ```bash
    git clone [https://github.com/DE41H/django-metro-ticketing-system.git](https://github.com/DE41H/django-metro-ticketing-system.git)
    cd django-metro-ticketing-system
    ```

2.  **Configure Environment Variables:**
    Create a file named `.env.prod` in the root directory and populate it with secure credentials and settings.

    ```ini
    # .env.prod
    # WARNING: Must be changed for production deployment
    SECRET_KEY=your_long_and_complex_secret_key
    DEBUG=False 
    DJANGO_ALLOWED_HOSTS=your_domain.com, localhost, 127.0.0.1
    
    # Database Credentials
    POSTGRES_DB=metro_db
    POSTGRES_USER=metro_user
    POSTGRES_PASSWORD=secure_db_password
    ```

3.  **Build and Run Services:**
    The `--build` flag ensures the latest version of the application image is created. The `-d` flag runs the services in the background (detached mode).

    ```bash
    docker compose -f compose.prod.yaml up --build -d
    ```

4.  **One-Time Setup (Migrations & Static Collection):**
    Once the containers are running and the database is healthy, execute the necessary setup commands inside the `web` container.

    ```bash
    # Apply database migrations
    docker compose -f compose.prod.yaml exec web python manage.py migrate --no-input

    # Create the admin user
    docker compose -f compose.prod.yaml exec web python manage.py createsuperuser

    # Static files are collected automatically in Dockerfile.prod, but this command is safe to run
    # docker compose -f compose.prod.yaml exec web python manage.py collectstatic --no-input
    ```

5.  **Access:** The application is now running and accessible at `http://localhost/` (or your configured `DJANGO_ALLOWED_HOSTS`).

### 2. Development Setup (Local Django Server)

For local development without Nginx, the Django development server handles everything.

1.  **Install Dependencies:**
    ```bash
    pip install -r requirements.txt
    ```

2.  **Configure Settings:**
    Ensure `settings.DEBUG = True`. If you are using the media file serving approach (as discussed in previous steps), your `urls.py` must include the following for the development server to serve dynamic files:
    ```python
    # In urls.py
    from django.conf import settings
    from django.conf.urls.static import static

    if settings.DEBUG:
        urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
    ```

3.  **Run Migrations:**
    ```bash
    python manage.py migrate
    ```

4.  **Run the Server:**
    ```bash
    python manage.py runserver
    ```
    The application will be accessible at `http://127.0.0.1:8000/`.
